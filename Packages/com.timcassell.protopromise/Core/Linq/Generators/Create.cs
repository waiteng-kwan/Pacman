#if PROTO_PROMISE_DEBUG_ENABLE || (!PROTO_PROMISE_DEBUG_DISABLE && DEBUG)
#define PROMISE_DEBUG
#else
#undef PROMISE_DEBUG
#endif

using Proto.Promises.CompilerServices;
using System;
using System.Diagnostics;

namespace Proto.Promises.Linq
{
    /// <summary>
    /// Async iterator to provide to <see cref="AsyncEnumerable{T}.Create{TAsyncIterator}(TAsyncIterator)"/>.
    /// </summary>
    /// <typeparam name="T">The type of the elements that will be yielded from the async iterator.</typeparam>
    public interface IAsyncIterator<T>
    {
        /// <summary>
        /// The async function used to start the iteration.
        /// </summary>
        /// <param name="streamWriter">The writer used to yield values to the consumer of the <see cref="AsyncEnumerable{T}"/>.</param>
        /// <param name="cancelationToken">The <see cref="CancelationToken"/> used to notify that cancelation has been requested.</param>
        /// <returns>An <see cref="AsyncIteratorMethod"/> with an async state machine generated by the compiler.</returns>
        AsyncIteratorMethod Start(AsyncStreamWriter<T> streamWriter, CancelationToken cancelationToken);

        /// <summary>
        /// The async dispose function used to clean up resources when the <see cref="AsyncEnumerator{T}"/> has been disposed without ever starting.
        /// </summary>
        /// <returns>A <see cref="Promise"/> that represents the entire async disposal.</returns>
        /// <remarks>If <see cref="DisposeAsyncWithoutStart"/> is called, <see cref="Start(AsyncStreamWriter{T}, CancelationToken)"/> will not be called, and vice-versa.
        /// Only 1 will be called. This means you must perform resource disposal in both methods.</remarks>
        Promise DisposeAsyncWithoutStart();
    }

    /// <summary>
    /// Provides helper functions to create and operate on <see cref="AsyncEnumerable{T}"/> async streams.
    /// </summary>
#if !PROTO_PROMISE_DEVELOPER_MODE
    [DebuggerNonUserCode, StackTraceHidden]
#endif
    public static partial class AsyncEnumerable
    {
        // We use AsyncEnumerableMethod instead of Promise so it can specially handle early-exits (`break` keyword).

        /// <summary>
        /// Create a new <see cref="AsyncEnumerable{T}"/> async stream from the specified <paramref name="asyncIterator"/> function.
        /// </summary>
        public static AsyncEnumerable<T> Create<T>(Func<AsyncStreamWriter<T>, CancelationToken, AsyncIteratorMethod> asyncIterator)
            => AsyncEnumerable<T>.Create(asyncIterator);

        /// <summary>
        /// Create a new <see cref="AsyncEnumerable{T}"/> async stream from the specified <paramref name="captureValue"/> and <paramref name="asyncIterator"/> function.
        /// </summary>
        public static AsyncEnumerable<T> Create<T, TCapture>(TCapture captureValue, Func<TCapture, AsyncStreamWriter<T>, CancelationToken, AsyncIteratorMethod> asyncIterator)
            => AsyncEnumerable<T>.Create(captureValue, asyncIterator);

        /// <summary>
        /// Create a new <see cref="AsyncEnumerable{T}"/> async stream from the specified <paramref name="asyncIterator"/>.
        /// </summary>
        /// <remarks>Use this method if you are capturing disposable resources.</remarks>
        public static AsyncEnumerable<T> Create<T, TAsyncIterator>(TAsyncIterator asyncIterator)
            where TAsyncIterator : IAsyncIterator<T>
            => AsyncEnumerable<T>.Create(asyncIterator);
    }

    partial struct AsyncEnumerable<T>
    {
        /// <summary>
        /// Create a new <see cref="AsyncEnumerable{T}"/> async stream from the specified <paramref name="asyncIterator"/> function.
        /// </summary>
        public static AsyncEnumerable<T> Create(Func<AsyncStreamWriter<T>, CancelationToken, AsyncIteratorMethod> asyncIterator)
        {
            ValidateArgument(asyncIterator, nameof(asyncIterator), 1);

            return Create(new Internal.AsyncIterator<T>(asyncIterator));
        }

        /// <summary>
        /// Create a new <see cref="AsyncEnumerable{T}"/> async stream from the specified <paramref name="captureValue"/> and <paramref name="asyncIterator"/> function.
        /// </summary>
        public static AsyncEnumerable<T> Create<TCapture>(TCapture captureValue, Func<TCapture, AsyncStreamWriter<T>, CancelationToken, AsyncIteratorMethod> asyncIterator)
        {
            ValidateArgument(asyncIterator, nameof(asyncIterator), 1);

            return Create(new Internal.AsyncIterator<T, TCapture>(captureValue, asyncIterator));
        }

        /// <summary>
        /// Create a new <see cref="AsyncEnumerable{T}"/> async stream from the specified <paramref name="asyncIterator"/>.
        /// </summary>
        /// <remarks>Use this method if you are capturing disposable resources.</remarks>
        public static AsyncEnumerable<T> Create<TAsyncIterator>(TAsyncIterator asyncIterator)
            where TAsyncIterator : IAsyncIterator<T>
        {
            ValidateArgument(asyncIterator, nameof(asyncIterator), 1);

            var enumerable = Internal.AsyncEnumerableCreate<T, TAsyncIterator>.GetOrCreate(asyncIterator);
            return new AsyncEnumerable<T>(enumerable);
        }
    }

    partial struct AsyncEnumerable<T>
    {
        // Calls to this get compiled away in RELEASE mode
        static partial void ValidateArgument<TArg>(TArg arg, string argName, int skipFrames);

#if PROMISE_DEBUG
        static partial void ValidateArgument<TArg>(TArg arg, string argName, int skipFrames)
        {
            Internal.ValidateArgument(arg, argName, skipFrames + 1);
        }
#endif
    }
}